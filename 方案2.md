# 方案2：Docker容器 + 独立网络

## 概述

通过Docker容器创建独立的网络环境，将wenyan-mcp部署在容器中，避免VPN导致的IP变化问题，实现稳定的文章发布功能。

## 优势

✅ **网络隔离**：容器有独立的网络环境，不受主机VPN影响
✅ **环境一致性**：容器内环境固定，不依赖主机环境
✅ **易于部署**：一键启动/停止，支持版本管理
✅ **安全性**：容器与主机隔离，不会影响主机环境
✅ **可移植性**：可以在任何安装了Docker的机器上运行

## 劣势

❌ **学习成本**：需要了解Docker基础知识
❌ **资源消耗**：Docker本身占用系统资源
❌ **配置复杂**：需要设置网络和端口映射

## 关于跨设备使用

**重要说明**：使用方案2后，即使换到另一台笔记本电脑，您仍然需要：

1. **在新设备上安装Docker**
2. **重新配置IP白名单**（新设备的IP会不同）
3. **重新部署容器**

**不是**"相当于还是在原来的IP地址发文章"，而是：
- 每台设备都有自己的IP地址
- 需要在微信公众号后台为每台设备添加IP白名单
- 容器只是解决了单台设备上VPN导致的IP变化问题

## 实现步骤

### 1. 安装Docker

```bash
# macOS安装Docker Desktop
brew install --cask docker

# 启动Docker Desktop
open /Applications/Docker.app
```

### 2. 构建Docker镜像

```bash
# 在项目根目录执行
docker build -t wenyan-mcp .

# 查看构建的镜像
docker images | grep wenyan-mcp
```

### 3. 创建Docker网络

```bash
# 创建自定义网络
docker network create wenyan-network

# 查看网络列表
docker network ls
```

### 4. 创建Docker Compose配置

```yaml
# docker-compose.yml
version: '3.8'

services:
  wenyan-mcp:
    image: wenyan-mcp
    container_name: wenyan-mcp-publisher
    restart: unless-stopped
    networks:
      wenyan-network:
        ipv4_address: 172.20.0.2
    environment:
      - WECHAT_APP_ID=wxae7dd3f82a7b0976
      - WECHAT_APP_SECRET=958c1e19fe39bdbc68c4d2ec87cf6537
      - HOST_IMAGE_PATH=/Users/dabaobaodemac/Desktop/Articles/images
    volumes:
      - /Users/dabaobaodemac/Desktop/Articles:/mnt/host-downloads
      - /Users/dabaobaodemac/Desktop/Articles/images:/mnt/host-images
    ports:
      - "3000:3000"  # 可选：如果需要Web界面
    command: ["node", "dist/index.js"]

networks:
  wenyan-network:
    driver: bridge
    ipam:
      config:
        - subnet: 172.20.0.0/16
```

### 5. 创建启动脚本

```bash
#!/bin/bash
# start-docker-publisher.sh

echo "🐳 启动Docker文章发布服务..."

# 检查Docker是否运行
if ! docker info > /dev/null 2>&1; then
    echo "❌ Docker未运行，请先启动Docker Desktop"
    exit 1
fi

# 检查镜像是否存在
if ! docker images | grep -q wenyan-mcp; then
    echo "🔨 构建Docker镜像..."
    docker build -t wenyan-mcp .
fi

# 创建网络（如果不存在）
if ! docker network ls | grep -q wenyan-network; then
    echo "🌐 创建Docker网络..."
    docker network create wenyan-network
fi

# 创建必要的目录
mkdir -p ~/Desktop/Articles
mkdir -p ~/Desktop/Articles/images
mkdir -p ~/Desktop/Articles/processed

# 启动容器
echo "🚀 启动容器..."
docker-compose up -d

echo "✅ 服务已启动！"
echo "📁 文章目录: ~/Desktop/Articles"
echo "🖼️  图片目录: ~/Desktop/Articles/images"
echo ""
echo "使用以下命令查看日志:"
echo "docker-compose logs -f wenyan-mcp"
```

### 6. 创建监控脚本

```javascript
// docker-monitor.js
const fs = require('fs');
const path = require('path');
const { exec } = require('child_process');

const WATCH_DIR = '/Users/dabaobaodemac/Desktop/Articles';
const PROCESSED_DIR = '/Users/dabaobaodemac/Desktop/Articles/processed';

// 确保目录存在
if (!fs.existsSync(WATCH_DIR)) {
    fs.mkdirSync(WATCH_DIR, { recursive: true });
}
if (!fs.existsSync(PROCESSED_DIR)) {
    fs.mkdirSync(PROCESSED_DIR, { recursive: true });
}

// 通过Docker容器发布文章
async function publishArticle(filePath) {
    return new Promise((resolve, reject) => {
        const fileName = path.basename(filePath);
        const content = fs.readFileSync(filePath, 'utf8');
        
        // 创建临时文件用于Docker容器读取
        const tempFile = path.join(WATCH_DIR, `temp_${fileName}`);
        fs.writeFileSync(tempFile, content);
        
        // 通过Docker容器处理
        const command = `docker exec wenyan-mcp-publisher node -e "
            const fs = require('fs');
            const { publishToDraft } = require('./dist/publish');
            
            const content = fs.readFileSync('/mnt/host-downloads/temp_${fileName}', 'utf8');
            const frontmatterMatch = content.match(/^---\\n([\\s\\S]*?)\\n---\\n([\\s\\S]*)$/);
            
            if (frontmatterMatch) {
                const frontmatter = frontmatterMatch[1];
                const body = frontmatterMatch[2];
                
                const titleMatch = frontmatter.match(/title:\\s*(.+)/);
                const coverMatch = frontmatter.match(/cover:\\s*(.+)/);
                
                const title = titleMatch ? titleMatch[1].trim() : '未命名文章';
                const cover = coverMatch ? coverMatch[1].trim() : '';
                
                publishToDraft(title, body, cover).then(result => {
                    console.log('SUCCESS:' + JSON.stringify(result));
                }).catch(error => {
                    console.log('ERROR:' + error.message);
                });
            }
        "`;
        
        exec(command, (error, stdout, stderr) => {
            // 清理临时文件
            if (fs.existsSync(tempFile)) {
                fs.unlinkSync(tempFile);
            }
            
            if (error) {
                console.error(`❌ 发布失败: ${error.message}`);
                reject(error);
                return;
            }
            
            if (stdout.includes('SUCCESS:')) {
                const result = JSON.parse(stdout.split('SUCCESS:')[1]);
                console.log(`✅ 文章发布成功！媒体ID: ${result.media_id}`);
                
                // 移动文件到已处理目录
                const processedPath = path.join(PROCESSED_DIR, fileName);
                fs.renameSync(filePath, processedPath);
                console.log(`📁 文件已移动到: ${processedPath}`);
                
                resolve(result);
            } else if (stdout.includes('ERROR:')) {
                const errorMsg = stdout.split('ERROR:')[1];
                console.error(`❌ 发布失败: ${errorMsg}`);
                reject(new Error(errorMsg));
            }
        });
    });
}

// 监控文件变化
function startWatching() {
    console.log(`🔍 开始监控目录: ${WATCH_DIR}`);
    console.log(`📁 已处理文件将移动到: ${PROCESSED_DIR}`);
    console.log('按 Ctrl+C 停止监控\n');
    
    fs.watch(WATCH_DIR, (eventType, filename) => {
        if (eventType === 'rename' && filename && filename.endsWith('.md') && !filename.startsWith('temp_')) {
            const filePath = path.join(WATCH_DIR, filename);
            
            setTimeout(() => {
                if (fs.existsSync(filePath)) {
                    publishArticle(filePath).catch(console.error);
                }
            }, 1000);
        }
    });
}

// 启动监控
startWatching();
```

## 使用方法

### 1. 启动Docker服务

```bash
# 方法1：使用启动脚本
chmod +x start-docker-publisher.sh
./start-docker-publisher.sh

# 方法2：手动启动
docker-compose up -d
```

### 2. 启动文件监控

```bash
# 在新的终端窗口运行
node docker-monitor.js
```

### 3. 发布文章

1. 将Markdown文章保存到 `~/Desktop/Articles/` 目录
2. 将图片文件保存到 `~/Desktop/Articles/images/` 目录
3. 确保文章包含正确的frontmatter格式
4. 监控脚本会自动检测并发布到公众号草稿箱

## 文章格式要求

```markdown
---
title: 文章标题
cover: /mnt/host-images/cover.jpg
---

文章内容...
```

## 管理命令

### 查看容器状态

```bash
# 查看运行中的容器
docker ps

# 查看容器日志
docker-compose logs -f wenyan-mcp

# 查看容器详细信息
docker inspect wenyan-mcp-publisher
```

### 停止服务

```bash
# 停止容器
docker-compose down

# 停止并删除容器
docker-compose down --rmi all
```

### 重启服务

```bash
# 重启容器
docker-compose restart

# 重新构建并启动
docker-compose up -d --build
```

## 网络配置

### 查看容器网络

```bash
# 查看网络列表
docker network ls

# 查看网络详情
docker network inspect wenyan-network

# 查看容器IP
docker inspect wenyan-mcp-publisher | grep IPAddress
```

### 测试网络连接

```bash
# 进入容器测试网络
docker exec -it wenyan-mcp-publisher ping api.weixin.qq.com

# 测试微信API连接
docker exec -it wenyan-mcp-publisher curl -s "https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&appid=wxae7dd3f82a7b0976&secret=958c1e19fe39bdbc68c4d2ec87cf6537"
```

## 故障排除

### 常见问题

1. **容器启动失败**
   ```bash
   # 查看详细错误信息
   docker-compose logs wenyan-mcp
   
   # 检查端口占用
   lsof -i :3000
   ```

2. **网络连接问题**
   ```bash
   # 检查容器网络
   docker exec wenyan-mcp-publisher ip addr
   
   # 测试外网连接
   docker exec wenyan-mcp-publisher curl -I https://www.baidu.com
   ```

3. **文件权限问题**
   ```bash
   # 检查目录权限
   ls -la ~/Desktop/Articles
   
   # 修改权限
   chmod 755 ~/Desktop/Articles
   ```

### 重置环境

```bash
# 完全重置Docker环境
docker-compose down --volumes --rmi all
docker network rm wenyan-network
docker system prune -f

# 重新构建
./start-docker-publisher.sh
```

## 性能优化

### 1. 资源限制

```yaml
# 在docker-compose.yml中添加
services:
  wenyan-mcp:
    # ... 其他配置
    deploy:
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'
```

### 2. 日志管理

```yaml
# 限制日志大小
services:
  wenyan-mcp:
    # ... 其他配置
    logging:
      driver: "json-file"
      options:
        max-size: "10m"
        max-file: "3"
```

## 安全考虑

1. **环境变量安全**：不要在代码中硬编码敏感信息
2. **网络隔离**：容器网络与主机网络隔离
3. **文件权限**：限制容器对主机文件的访问权限
4. **定期更新**：定期更新Docker镜像和依赖

## 总结

方案2适合：
- 需要解决VPN导致IP变化问题的用户
- 希望环境稳定一致的用户
- 有一定Docker基础的用户
- 需要跨设备部署的用户

虽然配置相对复杂，但能从根本上解决网络环境问题，提供稳定的发布服务。 
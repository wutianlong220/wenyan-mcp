# 微信公众号文章发布工具 - 成功经验总结

## 项目背景

开发一个本地文件监控脚本，自动将Markdown文章发布到微信公众号草稿箱。文章和图片都放在同一个目录中，实现自动化发布流程。

## 遇到的问题及解决过程

### 1. 环境变量加载问题

**问题描述：**
- 最初使用 `env.local` 文件存储环境变量
- 但 `publish.js` 在模块加载时就读取了环境变量，而我们的环境变量是在运行时设置的
- 导致 `process.env.WECHAT_APP_ID` 和 `process.env.WECHAT_APP_SECRET` 始终为空

**解决方案：**
```typescript
// 修改前：模块加载时读取
const appId = process.env.WECHAT_APP_ID || "";
const appSecret = process.env.WECHAT_APP_SECRET || "";

// 修改后：函数调用时动态读取
function getAppId(): string {
    return process.env.WECHAT_APP_ID || "";
}

function getAppSecret(): string {
    return process.env.WECHAT_APP_SECRET || "";
}
```

**关键经验：**
- 环境变量必须在运行时动态读取，而不是在模块加载时静态读取
- 使用函数封装环境变量读取，确保每次调用都能获取最新值

### 2. ES模块兼容性问题

**问题描述：**
- 项目使用ES模块（`"type": "module"`）
- 但脚本使用了CommonJS的 `require()` 语法
- 导致 `ReferenceError: require is not defined in ES module scope`

**解决方案：**
```typescript
// 修改前：CommonJS语法
const fs = require('fs');
const path = require('path');
const { publishToDraft } = require('./dist/publish');

// 修改后：ES模块语法
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import { publishToDraft } from './dist/publish.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
```

**关键经验：**
- 在ES模块环境中，必须使用 `import` 语法
- 需要手动构建 `__dirname` 和 `__filename`，因为ES模块中没有这些变量

### 3. 图片上传的核心问题

**问题描述：**
- 使用 `formdata-node` 库生成FormData
- 微信API返回 `41005` 错误：`media data missing`
- 文件读取正常，但API无法识别上传的数据

**根本原因：**
- `formdata-node` 生成的multipart/form-data格式与微信API不完全兼容
- Node.js的 `fetch` + `formdata-node` 组合在某些情况下会导致数据丢失

**解决方案：**
```typescript
// 修改前：使用formdata-node
import { FormData, File } from 'formdata-node';
import { fileFromPath } from 'formdata-node/file-from-path';

const form = new FormData();
form.append("media", fileData, fileName);
const response = await fetch(url, {
    method: 'POST',
    body: form as any,
});

// 修改后：使用form-data + node-fetch
import FormData from 'form-data';
import fetch from 'node-fetch';

const form = new FormData();
form.append('media', fileData, { filename: fileName });
const response = await fetch(url, {
    method: 'POST',
    body: form,
    headers: form.getHeaders(),
});
```

**关键经验：**
- `form-data` 库专门为Node.js设计，与各种API兼容性更好
- `node-fetch@2` 比原生fetch更稳定，特别是在处理FormData时
- 必须设置正确的headers：`form.getHeaders()`

### 4. 文件路径处理问题

**问题描述：**
- 图片使用相对路径（如 `cover-image.jpg`）
- 但上传函数需要绝对路径
- 路径转换逻辑复杂且容易出错

**解决方案：**
```typescript
// 简化路径处理逻辑
async function uploadImage(imageUrl: string, accessToken: string, fileName?: string): Promise<UploadResponse> {
    if (imageUrl.startsWith("http")) {
        // 处理网络图片
        const response = await fetch(imageUrl);
        const buffer = await response.buffer();
        const fileNameFromUrl = fileName || imageUrl.split('/').pop() || 'image.jpg';
        return await uploadMaterial('image', buffer, fileNameFromUrl, accessToken);
    } else {
        // 处理本地图片
        let localImagePath = imageUrl;
        if (!path.isAbsolute(imageUrl)) {
            localImagePath = path.resolve('/Users/dabaobaodemac/Desktop/Articles', imageUrl);
        }
        if (!fs.existsSync(localImagePath)) {
            throw new Error(`图片文件不存在: ${localImagePath}`);
        }
        const buffer = fs.readFileSync(localImagePath);
        const fileNameFromLocal = fileName || path.basename(localImagePath);
        return await uploadMaterial('image', buffer, fileNameFromLocal, accessToken);
    }
}
```

**关键经验：**
- 统一使用Buffer处理文件，避免类型转换问题
- 简化路径逻辑，减少出错可能
- 添加文件存在性检查，提供清晰的错误信息

## 最终成功的技术栈

### 核心依赖
```json
{
  "form-data": "^4.0.0",
  "node-fetch": "^2.7.0",
  "@types/node-fetch": "^2.6.11"
}
```

### 关键代码结构
```typescript
// 1. 环境变量动态读取
function getAppId(): string {
    return process.env.WECHAT_APP_ID || "";
}

// 2. 图片上传使用form-data
async function uploadMaterial(type: string, fileData: Buffer, fileName: string, accessToken: string) {
    const form = new FormData();
    form.append('media', fileData, { filename: fileName });
    const response = await fetch(url, {
        method: 'POST',
        body: form,
        headers: form.getHeaders(),
    });
}

// 3. 文件读取使用Buffer
const buffer = fs.readFileSync(localImagePath);
```

## 调试技巧

### 1. 分步调试
- 先测试环境变量加载
- 再测试文件读取
- 最后测试API调用

### 2. 详细日志
```typescript
console.log(`📤 开始上传素材: ${type}, ${fileName}`);
console.log(`📊 文件数据大小: ${fileData.length} 字节`);
console.log(`🌐 发送请求到: ${url}`);
console.log(`📡 响应状态: ${response.status}`);
console.log(`📋 响应数据:`, data);
```

### 3. 错误处理
```typescript
if (data.errcode) {
    console.error(`❌ API错误: ${data.errcode} - ${data.errmsg}`);
    throw new Error(`上传失败，错误码：${data.errcode}，错误信息：${data.errmsg}`);
}
```

## 成功的关键因素

1. **正确的技术选型**：`form-data` + `node-fetch@2` 组合
2. **环境变量动态读取**：确保运行时能获取到正确的配置
3. **ES模块兼容性**：正确处理模块导入和路径
4. **详细的调试信息**：快速定位问题所在
5. **简化的文件处理**：统一使用Buffer，避免类型转换问题

## 经验总结

1. **API兼容性很重要**：不同的HTTP客户端库对multipart/form-data的处理可能不同
2. **环境变量时机**：必须在正确的时机读取环境变量
3. **模块系统一致性**：确保所有代码都使用相同的模块系统
4. **调试信息必不可少**：详细的日志能快速定位问题
5. **简化胜于复杂**：简单的解决方案往往更可靠

## 最终效果

✅ 环境变量自动加载  
✅ 图片文件正确上传  
✅ 文章成功发布到微信公众号草稿箱  
✅ 支持相对路径图片引用  
✅ 完整的错误处理和日志记录  

这个项目成功的关键在于解决了API兼容性问题，特别是图片上传的FormData格式问题。通过使用专门为Node.js设计的`form-data`库，我们成功绕过了`formdata-node`的兼容性问题，最终实现了稳定的自动化发布流程。 